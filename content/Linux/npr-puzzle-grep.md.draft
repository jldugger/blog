Title: Solving the Sunday Puzzle with coreutils
Date: 2011-05-16

The entry deadline for week's NPR Sunday puzzle has passed, so I thought I'd 
share a couple tools to help solve word puzzles, like this week's: 

the 4x4 square crossword with common uncapitalized words, using no letter is 
used more than once:
NAGS
E
W
T

My secret weapon? GNU coreutils. W

1. First, lets identify a dictionary of words. I'm using the American English 
dictionary provided by Ubuntu /usr/share/dict/words. The format of this file 
is one word per line. Every version of a word gets a line, including 
contractions and possessives like "Abe's". We use | (pipe) to chain the output
of one command into the input of the next. Cat simply outputs a file, and wc -l
counts the lines in it.

    laptop:~$ cat /usr/share/dict/words | wc -l
    98569

2. Its safe to assume no apostrophes are in the puzzle. Grep reads input and 
outputs only those lines that match a regular expression (regex).  Using the -v
option to grep changes it to output only lines that don't match. Using \ to 
escape the apostrophe prevents bash from parsing it, so it can be passed into 
grep as a regex.

    laptop:~$ cat /usr/share/dict/words | grep -v \' | wc -l
    74059

3. That's a lot of words to fuddle around with, so lets start winnowing this 
down. Firstly, we only care about 4 letter words. We can use grep to give us 
only these words, using the regular expression "^....$". Caret (^) represents 
the start of a line, and $ represents the end of one. Each period is a free 
choice for grep, able to match any one character in the input. Four of those 
will do then.

    laptop:~$ cat /usr/share/dict/words | grep -v "'" | grep "^....$" | wc -l
    3174

4. Having cut the search space by 96 percent, we now turn to the clues for... 
clues. Since we have the first row and first column, we know which letters 
every word can start with. Grep treats symbols within brackets as alternatives,
meaning any one symbol will match. We'll alter the above pipeline slightly to 
keep cutting down.

    laptop:~$ cat /usr/share/dict/words | grep -v "'" | grep "^[agsewt]...$" | wc -l
    777

5. Every letter must be unique in the puzzle. We know that the letters in nags
and newt cannot be anywhere but the first letter, so we'll exclude all words 
that violate this. As an alternative to -v, we can use carets inside brackets 
to indicate "not". 

    laptop:~$ cat /usr/share/dict/words | grep -v "'" | grep "^[agsewt][^nagsewt][^nagsewt][^nagsewt]$" | wc -l
    131

6. Next, we can rule out words with repeated letters, like solo and wool. To do
this quickly, we'll need to use backreferences. Backreferences can be slow, but
since we've only got 131 four letter words at the end of the pipeline, the 
performance will be fine if we add it there.

    cat /usr/share/dict/words | grep -v "'" | grep "^[agsewt][^nagsewt][^nagsewt][^nagsewt]$" | grep -vE "([a-z]).*(\1)" | wc -l
    106

7. Starting to get close! From here on out, this plays a lot like sudoku. Our 
goal is now to start constructing regex for each word. To start off, we've only
got 7 options for 2 across:

    laptop:~$ cat /usr/share/dict/words | grep -v "'" | grep "^e[^nagsewt][^nagsewt][^nagsewt]$" | grep -vE "([a-z]).*(\1)"
    echo
    ecru
    emir
    epic
    euro
    evil
    expo

We can rewrite this without the negations now, which will come in handy
    laptop:~$ cat /usr/share/dict/words | grep "^e[cmpuvx][hipr][cloru]$" | grep -vE "([a-z]).*(\1)" | wc -l
    7

Now we build a similar regex for 2 down, adding in what we know about their 
intersection already (cmpuvx)
    laptop:~$ cat /usr/share/dict/words | grep -v "'" | grep "^a[cmpuvx][^nagsewt][^nagsewt]$" | grep -vE "([a-z]).*(\1)"
    achy
    acid
    amid
    amok
    avid

We can rewrite this one as 

    laptop:~$ cat /usr/share/dict/words | grep -v "'" | grep "^a[cmv][hio][dky]$" | grep -vE "([a-z]).*(\1)" | wc -l
    5


Applying the same logic to 3 down yields "^g[ir][lriu][bdlmp]$"

4 down yields "^s[lu][cilmoru][bdfhkmopr]$"

8. Taking the last positions in each regex, we finally construct a pipeline to 
solve 4 across:
    cat /usr/share/dict/words | grep -v "'" | grep "^t[dky][bdlmp][bdfhkmopr]$" | grep -vE "([a-z]).*(\1)"
    typo

A unique solution to 4 across!

9.  Revisiting 2 down with this new fact also yields a unique answer. I leave
it from here as an exercise to the reader to solve the entire puzzle.
